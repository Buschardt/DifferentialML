#%%
import numpy as np
import matplotlib.pyplot as plt
import torch
from scipy.stats import norm
#%%
def f(my_x, my_y):
    return my_x**2 - my_y**2

#%%
x = torch.linspace(2,6,5).requires_grad_()
y = torch.linspace(4,8,5).requires_grad_()
torch.autograd.grad(f(x,y), [x,y], torch.ones(5,))


#%%
def genPaths(S0, K, T, sigma, r, nObs, nSteps, nSamples = 1):
    dt = T/nSteps
    dW = torch.tensor(np.random.normal(0, 1, [nSteps, nObs, nSamples]))
    
    ST = S0 * torch.cumprod(torch.exp((r-sigma**2/2)*dt+sigma*torch.sqrt(dt)*dW), axis=0)

    return ST

def euroCallPrice(S0, K, T, sigma, r, nObs, nSteps, nSamples = 1):
    ST = genPaths(S0, K, T, sigma, r, nObs, nSteps, nSamples)
    zero = [0] * nSamples 
    payoff = torch.maximum(ST[-1,:,:] - K, torch.tensor(zero))
    C = torch.exp(-r*T) * torch.mean(payoff, axis = 0)

    return C

#True BS greeks
def deltaBS(S0, K, T, sigma, r):
    d1 = 1/(sigma*np.sqrt(T)) * (np.log(S0/K) + (r+(sigma**2)/2) * T )
    return norm.cdf(d1)

def vegaBS(S0, K, T, sigma, r):
    d1 = 1/(sigma*np.sqrt(T)) * (np.log(S0/K) + (r+(sigma**2)/2) * T )
    return S0 * norm.pdf(d1) * np.sqrt(T)

def thetaBS(S0, K, T, sigma, r):
    d1 = 1/(sigma*np.sqrt(T)) * (np.log(S0/K) + (r+(sigma**2)/2) * T )
    d2 = d1 - sigma * np.sqrt(T)
    
    theta = -((S0 * norm.pdf(d1) * sigma)/(2*np.sqrt(T))) - r * K * np.exp(-r*T) * norm.cdf(d2)
    return theta

def rhoBS(S0, K, T, sigma, r):
    d1 = 1/(sigma*np.sqrt(T)) * (np.log(S0/K) + (r+(sigma**2)/2) * T )
    d2 = d1 - sigma * np.sqrt(T)
    
    rho = K * T * np.exp(-r*T) * norm.cdf(d2)
    return rho

def C_BS(S0, K, T, sigma, r):
    d1 = 1/(sigma*np.sqrt(T)) * (np.log(S0/K) + (r+(sigma**2)/2) * T )
    d2 = d1 - sigma * np.sqrt(T)

    C = norm.cdf(d1)*S0 - norm.cdf(d2)*K*np.exp(-r*T)
    return C

#greeks Pytorch autograd
def mcGreeks(S0, K, T, sigma, r):
    #if torch.is_tensor(S0) == False:
    S0 = torch.tensor(S0).requires_grad_()
    K = torch.tensor(K).requires_grad_()
    T = torch.tensor(T).requires_grad_()
    sigma = torch.tensor(sigma).requires_grad_()
    r = torch.tensor(r).requires_grad_()

    #nSamples = list(sigma.size())[0]
    nSamples = torch.max(torch.tensor([S0.size(), K.size(), T.size(), sigma.size(), r.size()])).item()
    
    greeks = torch.autograd.grad(euroCallPrice(S0, K, T, sigma, r, 10000, 100, nSamples), [S0, K, T, sigma, r], torch.ones(nSamples,))

    return greeks
#%%
S0 = np.linspace(90,110,11)
K = np.linspace(100,120,11)
T = np.linspace(0.9,1.1,11)
sigma = np.linspace(0.05,0.2, 11)
r = np.linspace(0,0.5,11)
print("True BS delta = ", deltaBS(S0, 110, 1, 0.12, 0.03))
print("Delta from MC and AAD = ", mcGreeks(S0, K, T, sigma, r))

#%%
greeks = mcGreeks(S0, K, T, sigma, r)
#%%
plt.plot(r, greeks[4])

#%%
#delta comp
nSamples = 30
S0 = [100.] * nSamples
K = [105.] * nSamples
T = [1.] * nSamples
sigma = [0.2] * nSamples
r = [0.05] * nSamples

x = np.linspace(50, 150, nSamples)
plt.figure(figsize=(16,12))
plt.plot(x, deltaBS(x, 105, 1, 0.2, 0.05), color='black', label='True Delta')
plt.plot(x, mcGreeks(x, K, T, sigma, r)[0], color='red', linestyle='dotted', label='Delta generated by Pytorch')
plt.xlabel('Spot price')
plt.ylabel('Delta')
plt.legend()
plt.savefig('DeltaBS.png')

#%%
#Vega comp
plt.figure(figsize=(16,12))
plt.plot(x, vegaBS(x, 105, 1, 0.2, 0.05), color='black', label='True Vega')
plt.plot(x, mcGreeks(x, K, T, sigma, r)[3], color='red', linestyle='dotted', label='Vega generated by Pytorch')
plt.xlabel('Spot price')
plt.ylabel('Vega')
plt.legend()
plt.savefig('VegaBS.png')

#%%
#Theta comp
plt.figure(figsize=(16,12))
plt.plot(x, thetaBS(x, 105, 1, 0.2, 0.05), color='black', label='True Theta')
plt.plot(x, mcGreeks(x, K, T, sigma, r)[2], color='red', linestyle='dotted', label='Theta generated by Pytorch')
plt.xlabel('Spot price')
plt.ylabel('Theta')
plt.legend()
plt.savefig('ThetaBS.png')

#%%
#Rho comp
plt.figure(figsize=(16,12))
plt.plot(x, rhoBS(x, 105, 1, 0.2, 0.05), color='black', label='True Rho')
plt.plot(x, mcGreeks(x, K, T, sigma, r)[4], color='red', linestyle='dotted', label='Rho generated by Pytorch')
plt.xlabel('Spot price')
plt.ylabel('Rho')
plt.legend()
plt.savefig('RhoBS.png')

#%%
print("True BS price = ", C_BS(100, 105, 1, 0.2, 0.05))
print("MC price = ", euroCallPrice(torch.tensor(100.), torch.tensor(105.), torch.tensor(1.), torch.tensor(0.2), torch.tensor(0.05), 250000, 50))
